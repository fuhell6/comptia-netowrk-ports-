import tkinter as tk
import random
import json
import os
import time

# --- Data ---
ports_info = {
    20: (False, "FTP Data Transfer", "Transfers files"),
    21: (False, "FTP Control", "Controls file transfers"),
    23: (False, "Telnet", "Remote login without encryption"),
    25: (False, "SMTP", "Sends email"),
    67: (False, "DHCP Server", "Assigns IP addresses"),
    68: (False, "DHCP Client", "Receives IP addresses"),
    69: (False, "TFTP", "Transfers files without authentication"),
    80: (False, "HTTP", "Web browsing"),
    123: (False, "NTP", "Synchronizes clocks"),
    161: (False, "SNMP", "Manages network devices"),
    162: (False, "SNMP Trap", "Receives SNMP alerts"),
    389: (False, "LDAP", "Directory services"),
    445: (False, "SMB", "File sharing"),
    514: (False, "Syslog", "System logging"),
    443: (True, "HTTPS", "Secure web browsing"),
    587: (True, "SMTP (Secure)", "Sends email securely"),
    636: (True, "LDAPS", "Secure LDAP"),
    3389: (True, "RDP", "Remote Desktop"),
    5060: (False, "SIP", "Session Initiation Protocol"),
    5061: (True, "SIP (Secure)", "Secure Session Initiation Protocol"),
}

questions = list(ports_info.keys())
random.shuffle(questions)

# --- Variables ---
current_index = 0
correct_count = 0
wrong_count = 0
user_answers = {}
dark_mode = False

score_file = "user_scores.json"

# --- Functions ---
def save_scores():
    scores = {"correct": correct_count, "wrong": wrong_count, "answers": user_answers}
    with open(score_file, "w") as f:
        json.dump(scores, f, indent=4)

def load_scores():
    if os.path.exists(score_file):
        with open(score_file, "r") as f:
            return json.load(f)
    return {}

def center_window():
    root.update_idletasks()
    width = root.winfo_width()
    height = root.winfo_height()
    x = (root.winfo_screenwidth() // 2) - (width // 2)
    y = (root.winfo_screenheight() // 2) - (height // 2)
    root.geometry(f"{width}x{height}+{x}+{y}")

def toggle_dark_mode():
    global dark_mode
    dark_mode = not dark_mode
    # Update icon text
    if dark_mode:
        toggle_button.config(text="üåô")
    else:
        toggle_button.config(text="‚òÄÔ∏è")
    apply_theme()

def apply_theme():
    bg = "#1e1e1e" if dark_mode else "white"
    fg = "white" if dark_mode else "black"
    btn_bg = "#444" if dark_mode else "#f0f0f0"
    btn_active_bg = "#666" if dark_mode else "#ddd"

    back_btn_bg = "#ff8c00" if not dark_mode else "#ff9c1a"
    back_btn_active = "#e67e00" if not dark_mode else "#cc8400"
    next_btn_bg = "#28a745" if not dark_mode else "#3ecc57"
    next_btn_active = "#208636" if not dark_mode else "#2ca64a"

    def recursive_configure(widget):
        try:
            widget.configure(bg=bg)
        except:
            pass
        if isinstance(widget, tk.Button):
            if widget == back_btn:
                widget.configure(bg=back_btn_bg, fg="Black", activebackground=back_btn_active)
            elif widget == next_btn:
                widget.configure(bg=next_btn_bg, fg="Black", activebackground=next_btn_active)
            #elif widget == toggle_btn:
                #widget.configure(bg=btn_bg, fg=fg, activebackground=btn_active_bg)
            elif widget == reset_button:
                widget.configure(bg="#89CFF0", fg="black", activebackground="#00008B")
            elif widget == toggle_button:
                widget.configure(bg=btn_bg, fg=fg, activebackground=btn_active_bg)
            else:
                try:
                    widget.configure(bg=btn_bg, fg=fg, activebackground=btn_active_bg)
                except:
                    pass
        else:
            try:
                widget.configure(fg=fg)
            except:
                pass
        for child in widget.winfo_children():
            recursive_configure(child)

    recursive_configure(root)

def show_question():
    port = questions[current_index]
    info = ports_info[port]
    if current_index < len(questions) // 2:
        question_var.set(f"Is port {port} secure?")
        for btn in mcq_buttons:
            btn.pack_forget()
        true_button.pack()
        false_button.pack()
    else:
        question_var.set(f"What is port {port} used for?")
        true_button.pack_forget()
        false_button.pack_forget()
        answers = [info[1], info[2]]
        wrong = random.sample([v[1] for k, v in ports_info.items() if k != port], 2)
        options = list(set(answers + wrong))
        random.shuffle(options)
        for i, btn in enumerate(mcq_buttons):
            if i < len(options):
                btn.config(text=options[i], command=lambda t=options[i]: check_mcq_answer(t))
                btn.pack()
            else:
                btn.pack_forget()

    feedback_var.set("")
    score_var.set(f"‚úÖ Correct: {correct_count} ‚ùå Wrong: {wrong_count}")

def set_feedback(text, correct):
    # Always show green for correct and red for incorrect
    if correct:
        feedback_label.config(fg="green")
    else:
        feedback_label.config(fg="red")
    feedback_var.set(text)

def check_tf_answer(answer):
    global correct_count, wrong_count
    port = questions[current_index]
    is_secure = ports_info[port][0]

    if answer == is_secure:
        correct_count += 1
        feedback_var.set("‚úÖ Correct!")
        feedback_label.config(fg="lightgreen" if dark_mode else "green")
    else:
        wrong_count += 1
        feedback_var.set(f"‚ùå‚ùå Incorrect. Port {port} is {'secure' if is_secure else 'not secure'}.")
        feedback_label.config(fg="red")

    user_answers[current_index] = answer
    next_question()

def check_mcq_answer(selected):
    global correct_count, wrong_count
    port = questions[current_index]
    correct = ports_info[port][1]

    if selected == correct:
        correct_count += 1
        feedback_var.set("‚úÖ Correct!")
        feedback_label.config(fg="lightgreen" if dark_mode else "green")
    else:
        wrong_count += 1
        feedback_var.set(f"‚ùå‚ùå Incorrect. Port {port} is {ports_info[port][1]} ‚Äî {ports_info[port][2]}.")
        feedback_label.config(fg="red")

    user_answers[current_index] = selected
    next_question()

def next_question():
    global current_index
    if current_index < len(questions) - 1:
        current_index += 1
        show_question()
    else:
        save_scores()
        show_summary()

def previous_question():
    global current_index
    if current_index > 0:
        current_index -= 1
        show_question()

def matrix_rain_effect():
    global interrupt_rain
    interrupt_rain = False
    rain = tk.Toplevel(root)
    rain.attributes('-fullscreen', True)
    rain.configure(bg='black')
    canvas = tk.Canvas(rain, bg='black')
    canvas.pack(fill='both', expand=True)

    width = rain.winfo_screenwidth()
    height = rain.winfo_screenheight()
    columns = width // 15

    chars = [chr(i) for i in range(33, 127)]
    positions = [random.randint(0, height // 15) for _ in range(columns)]

    start_time = time.time()

    def stop_rain(event=None):
        nonlocal rain
        global interrupt_rain
        interrupt_rain = True
        rain.destroy()

    rain.bind("<Button-1>", stop_rain)
    rain.bind("<space>", stop_rain)
    rain.bind("<Escape>", stop_rain)

    def draw():
        nonlocal start_time
        if interrupt_rain:
            return
        canvas.delete("all")
        for i in range(columns):
            text = random.choice(chars)
            x = i * 15
            y = positions[i] * 15
            color = "#%02x%02x%02x" % (0, random.randint(128, 255), 0)
            canvas.create_text(x, y, text=text, fill=color, font=("Courier", 12, "bold"))
            positions[i] = (positions[i] + 1) % (height // 15)
        if time.time() - start_time < 5 and not interrupt_rain:
            rain.after(30, draw)
        else:
            rain.destroy()

    draw()

def reset_quiz():
    matrix_rain_effect()
    global current_index, correct_count, wrong_count, user_answers
    random.shuffle(questions)
    current_index = 0
    correct_count = 0
    wrong_count = 0
    user_answers = {}
    for widget in quiz_frame.winfo_children():
        widget.pack_forget()
    question_label.pack(pady=20)
    feedback_label.pack(pady=10)
    score_label.pack()
    reset_button.pack(pady=5)
    show_question()

def show_summary():
    question_var.set("üéâ Quiz Complete!")
    for widget in quiz_frame.winfo_children():
        widget.pack_forget()
    summary = f"Correct: {correct_count}\nIncorrect: {wrong_count}\n\nThanks for playing!"
    tk.Label(quiz_frame, text=summary, font=("Arial", 16)).pack(pady=20)
    #tk.Label(quiz_frame, text=summary, font=("Arial", 16)).pack(pady=20)
    #tk.Button(quiz_frame, text="Restart Quiz", width=20, height=2, command=reset_quiz).pack(pady=10)
    end_reset = tk.Button(quiz_frame, text="Restart Quiz", width=20, height=2, command=reset_quiz, bg="blue",fg="white", activebackground="#00008B")
    end_reset.pack(pady=10)

# --- GUI Setup ---
root = tk.Tk()
root.title("Port Security & Function Quiz")
root.geometry("750x550")
center_window()

# Top Frame for Dark Mode toggle
top_frame = tk.Frame(root)
top_frame.pack(side=tk.TOP, anchor='nw', padx=10, pady=10)

# Quiz Frame
quiz_frame = tk.Frame(root)
quiz_frame.pack(expand=True)

# Bottom Frame for Navigation
bottom_frame = tk.Frame(root)
bottom_frame.pack(side=tk.BOTTOM, pady=15)

question_var = tk.StringVar()
question_label = tk.Label(quiz_frame, textvariable=question_var, font=("Arial", 40), wraplength=720, justify="center")
question_label.pack(pady=20)

true_button = tk.Button(quiz_frame, text="True", width=20, height=2, command=lambda: check_tf_answer(True))
false_button = tk.Button(quiz_frame, text="False", width=20, height=2, command=lambda: check_tf_answer(False))

mcq_buttons = [
    tk.Button(quiz_frame, text="", width=40, height=2)
    for _ in range(4)
]

feedback_var = tk.StringVar()
feedback_label = tk.Label(quiz_frame, textvariable=feedback_var, font=("Arial", 16))
feedback_label.pack(pady=10)

score_var = tk.StringVar()
score_label = tk.Label(quiz_frame, textvariable=score_var, font=("Arial", 16))
score_label.pack()

reset_button = tk.Button(quiz_frame, text="üîÅ Reset üîÅ", width=20, command=reset_quiz)
reset_button.pack(pady=5)

# Dark mode toggle as icon button
toggle_button = tk.Button(top_frame, text="‚òÄÔ∏è", width=4, command=toggle_dark_mode)
toggle_button.pack()

# Toggle switch using Checkbutton
#toggle_var = tk.StringVar(value="Dark Mode: OFF")
#dark_switch = tk.Checkbutton(top_frame, textvariable=toggle_var, indicatoron=False, width=20, command=toggle_dark_mode)
#dark_switch.pack()

#toggle_btn = tk.Button(top_frame, text="üåô Toggle Dark Mode büåô ", width=24, command=toggle_dark_mode)
#toggle_btn.pack()

back_btn = tk.Button(bottom_frame, text="‚¨Ö Back ‚¨Ö ", width=20, height=4,  command=previous_question)
back_btn.pack(side=tk.LEFT, padx=55)

next_btn = tk.Button(bottom_frame, text="‚û° Next ‚û°", width=20, height=4, command=next_question)
next_btn.pack(side=tk.LEFT, padx=55)

show_question()
apply_theme()
root.mainloop()
